(let ((identity (lambda (x) x))) (let ((true 1)) (let ((false 0)) (let ((not (lambda (x) (if (= true x) false true)))) (let ((and (lambda (x y) (if (= false x) false (if (= false y) false true))))) (let ((or (lambda (x y) (if (= false x) (if (= false y) false true) true)))) (let ((none (new-tuple ))) (let ((some (lambda (x) (new-tuple x (new-tuple ))))) (let ((get (lambda (o) (aref o 0)))) (let ((nil (new-tuple ))) (let ((cons (lambda (x y) (new-tuple x y)))) (let ((head (lambda (xs) (aref xs 0)))) (let ((tail (lambda (xs) (aref xs 1)))) (let ((empty (lambda (xs) (= 0 (alen xs))))) (letrec ((size (lambda (xs) (if (empty xs) 0 (+ 1 (size (tail xs))))))) (letrec ((mapreduce (lambda (f g id xs) (if (empty xs) id (g (f (head xs)) (mapreduce f g id (tail xs))))))) (let ((map (lambda (f xs) (mapreduce f cons nil xs)))) (let ((reduce (lambda (f id xs) (mapreduce identity f id xs)))) (let ((tolist (lambda (arr) (letrec ((helper (lambda (index) (if (<= (alen arr) index) nil (cons (aref arr index) (helper (+ 1 index))))))) (helper 0))))) (let ((filter (lambda (p xs) (mapreduce identity (lambda (x y) (if (p x) (cons x y) y)) nil xs)))) (letrec ((find (lambda (p xs) (if (empty xs) none (if (p (head xs)) (some (head xs)) (find p (tail xs))))))) (letrec ((eqlist (lambda (x y) (if (and (empty x) (empty y)) true (if (or (empty x) (empty y)) false (and (if (and (number? (head x)) (number? (head y))) (= (head x) (head y)) (if (and (a? (head x)) (a? (head y))) (eqlist (head x) (head y)) false)) (eqlist (tail x) (tail y)))))))) (let ((eq (lambda (x y) (if (and (number? x) (number? y)) (= x y) (eqlist x y))))) (let ((test (lambda (x y) (if (eq x y) (print 1) (begin (print x) (print y)))))) (test (reduce * 1 (tolist (new-tuple 1 2 3 4))) 24)))))))))))))))))))))))))