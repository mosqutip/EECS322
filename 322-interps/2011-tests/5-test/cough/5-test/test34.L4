((let ([identity (make-closure :f0 (new-tuple))]) (let ([true 1]) (let ([false 0]) (let ([not (make-closure :f1 (new-tuple true false))]) (let ([and (make-closure :f2 (new-tuple false true))]) (let ([or (make-closure :f3 (new-tuple false true))]) (let ([none (new-tuple)]) (let ([some (make-closure :f4 (new-tuple))]) (let ([get (make-closure :f5 (new-tuple))]) (let ([nil (new-tuple)]) (let ([cons (make-closure :f6 (new-tuple))]) (let ([head (make-closure :f7 (new-tuple))]) (let ([tail (make-closure :f8 (new-tuple))]) (let ([empty (make-closure :f9 (new-tuple))]) (let ([size (new-tuple 0)]) (begin (aset size 0 (make-closure :f10 (new-tuple empty size tail))) (let ([mapreduce (new-tuple 0)]) (begin (aset mapreduce 0 (make-closure :f11 (new-tuple empty head mapreduce tail))) (let ([map (make-closure :f12 (new-tuple mapreduce cons nil))]) (let ([reduce (make-closure :f13 (new-tuple mapreduce identity))]) (let ([tolist (make-closure :f15 (new-tuple nil cons))]) (let ([filter (make-closure :f17 (new-tuple mapreduce identity cons nil))]) (let ([find (new-tuple 0)]) (begin (aset find 0 (make-closure :f18 (new-tuple empty none head some find tail))) (let ([eqlist (new-tuple 0)]) (begin (aset eqlist 0 (make-closure :f19 (new-tuple and empty true or false head eqlist tail))) (let ([eq (make-closure :f20 (new-tuple and eqlist))]) (let ([test (make-closure :f21 (new-tuple eq))]) (let ([x48 test]) ((closure-proc x48) (closure-vars x48) (let ([x49 (aref find 0)]) ((closure-proc x49) (closure-vars x49) (make-closure :f22 (new-tuple)) (let ([x50 tolist]) ((closure-proc x50) (closure-vars x50) (new-tuple 1 2 3 4))))) none))))))))))))))))))))))))))))))
(:f0 (frees x) x)
(:f1 (frees x) (let ([true (aref frees 0)]) (let ([false (aref frees 1)]) (if (= true x) false true))))
(:f2 (frees x y) (let ([false (aref frees 0)]) (let ([true (aref frees 1)]) (if (= false x) false (if (= false y) false true)))))
(:f3 (frees x y) (let ([false (aref frees 0)]) (let ([true (aref frees 1)]) (if (= false x) (if (= false y) false true) true))))
(:f4 (frees x) (new-tuple x (new-tuple)))
(:f5 (frees o) (aref o 0))
(:f6 (frees x y) (new-tuple x y))
(:f7 (frees xs) (aref xs 0))
(:f8 (frees xs) (aref xs 1))
(:f9 (frees xs) (= 0 (alen xs)))
(:f10 (frees xs) (let ([empty (aref frees 0)]) (let ([size (aref frees 1)]) (let ([tail (aref frees 2)]) (if (let ([x0 empty]) ((closure-proc x0) (closure-vars x0) xs)) 0 (+ 1 (let ([x1 (aref size 0)]) ((closure-proc x1) (closure-vars x1) (let ([x2 tail]) ((closure-proc x2) (closure-vars x2) xs))))))))))
(:f11 (frees args) (let ([f (aref args 0)]) (let ([g (aref args 1)]) (let ([id (aref args 2)]) (let ([xs (aref args 3)]) (let ([empty (aref frees 0)]) (let ([head (aref frees 1)]) (let ([mapreduce (aref frees 2)]) (let ([tail (aref frees 3)]) (if (let ([x3 empty]) ((closure-proc x3) (closure-vars x3) xs)) id (let ([x4 g]) ((closure-proc x4) (closure-vars x4) (let ([x5 f]) ((closure-proc x5) (closure-vars x5) (let ([x6 head]) ((closure-proc x6) (closure-vars x6) xs)))) (let ([x7 (aref mapreduce 0)]) ((closure-proc x7) (closure-vars x7) (new-tuple f g id (let ([x8 tail]) ((closure-proc x8) (closure-vars x8) xs)))))))))))))))))
(:f12 (frees f xs) (let ([mapreduce (aref frees 0)]) (let ([cons (aref frees 1)]) (let ([nil (aref frees 2)]) (let ([x9 (aref mapreduce 0)]) ((closure-proc x9) (closure-vars x9) (new-tuple f cons nil xs)))))))
(:f13 (frees args) (let ([f (aref args 0)]) (let ([id (aref args 1)]) (let ([xs (aref args 2)]) (let ([mapreduce (aref frees 0)]) (let ([identity (aref frees 1)]) (let ([x10 (aref mapreduce 0)]) ((closure-proc x10) (closure-vars x10) (new-tuple identity f id xs)))))))))
(:f15 (frees arr) (let ([nil (aref frees 0)]) (let ([cons (aref frees 1)]) (let ([helper (new-tuple 0)]) (begin (aset helper 0 (make-closure :f14 (new-tuple arr nil cons helper))) (let ([x13 (aref helper 0)]) ((closure-proc x13) (closure-vars x13) 0)))))))
(:f14 (frees index) (let ([arr (aref frees 0)]) (let ([nil (aref frees 1)]) (let ([cons (aref frees 2)]) (let ([helper (aref frees 3)]) (if (<= (alen arr) index) nil (let ([x11 cons]) ((closure-proc x11) (closure-vars x11) (aref arr index) (let ([x12 (aref helper 0)]) ((closure-proc x12) (closure-vars x12) (+ 1 index)))))))))))
(:f17 (frees p xs) (let ([mapreduce (aref frees 0)]) (let ([identity (aref frees 1)]) (let ([cons (aref frees 2)]) (let ([nil (aref frees 3)]) (let ([x14 (aref mapreduce 0)]) ((closure-proc x14) (closure-vars x14) (new-tuple identity (make-closure :f16 (new-tuple p cons)) nil xs))))))))
(:f16 (frees x y) (let ([p (aref frees 0)]) (let ([cons (aref frees 1)]) (if (let ([x15 p]) ((closure-proc x15) (closure-vars x15) x)) (let ([x16 cons]) ((closure-proc x16) (closure-vars x16) x y)) y))))
(:f18 (frees p xs) (let ([empty (aref frees 0)]) (let ([none (aref frees 1)]) (let ([head (aref frees 2)]) (let ([some (aref frees 3)]) (let ([find (aref frees 4)]) (let ([tail (aref frees 5)]) (if (let ([x17 empty]) ((closure-proc x17) (closure-vars x17) xs)) none (if (let ([x18 p]) ((closure-proc x18) (closure-vars x18) (let ([x19 head]) ((closure-proc x19) (closure-vars x19) xs)))) (let ([x20 some]) ((closure-proc x20) (closure-vars x20) (let ([x21 head]) ((closure-proc x21) (closure-vars x21) xs)))) (let ([x22 (aref find 0)]) ((closure-proc x22) (closure-vars x22) p (let ([x23 tail]) ((closure-proc x23) (closure-vars x23) xs)))))))))))))
(:f19 (frees x y) (let ([and (aref frees 0)]) (let ([empty (aref frees 1)]) (let ([true (aref frees 2)]) (let ([or (aref frees 3)]) (let ([false (aref frees 4)]) (let ([head (aref frees 5)]) (let ([eqlist (aref frees 6)]) (let ([tail (aref frees 7)]) (if (let ([x24 and]) ((closure-proc x24) (closure-vars x24) (let ([x25 empty]) ((closure-proc x25) (closure-vars x25) x)) (let ([x26 empty]) ((closure-proc x26) (closure-vars x26) y)))) true (if (let ([x27 or]) ((closure-proc x27) (closure-vars x27) (let ([x28 empty]) ((closure-proc x28) (closure-vars x28) x)) (let ([x29 empty]) ((closure-proc x29) (closure-vars x29) y)))) false (let ([x30 and]) ((closure-proc x30) (closure-vars x30) (if (let ([x31 and]) ((closure-proc x31) (closure-vars x31) (number? (let ([x32 head]) ((closure-proc x32) (closure-vars x32) x))) (number? (let ([x33 head]) ((closure-proc x33) (closure-vars x33) y))))) (= (let ([x34 head]) ((closure-proc x34) (closure-vars x34) x)) (let ([x35 head]) ((closure-proc x35) (closure-vars x35) y))) (if (let ([x36 and]) ((closure-proc x36) (closure-vars x36) (a? (let ([x37 head]) ((closure-proc x37) (closure-vars x37) x))) (a? (let ([x38 head]) ((closure-proc x38) (closure-vars x38) y))))) (let ([x39 (aref eqlist 0)]) ((closure-proc x39) (closure-vars x39) (let ([x40 head]) ((closure-proc x40) (closure-vars x40) x)) (let ([x41 head]) ((closure-proc x41) (closure-vars x41) y)))) false)) (let ([x42 (aref eqlist 0)]) ((closure-proc x42) (closure-vars x42) (let ([x43 tail]) ((closure-proc x43) (closure-vars x43) x)) (let ([x44 tail]) ((closure-proc x44) (closure-vars x44) y)))))))))))))))))
(:f20 (frees x y) (let ([and (aref frees 0)]) (let ([eqlist (aref frees 1)]) (if (let ([x45 and]) ((closure-proc x45) (closure-vars x45) (number? x) (number? y))) (= x y) (let ([x46 (aref eqlist 0)]) ((closure-proc x46) (closure-vars x46) x y))))))
(:f21 (frees x y) (let ([eq (aref frees 0)]) (if (let ([x47 eq]) ((closure-proc x47) (closure-vars x47) x y)) (print 1) (begin (print x) (print y)))))
(:f22 (frees x) (= 5 x)))